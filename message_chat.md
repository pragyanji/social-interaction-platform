# Message Chat — Architecture & Workflow

The message chat system uses two layers: a **REST API** for loading history and **WebSockets** (via Django Channels) for real-time messaging.

---

## High-Level Flow

```
User opens chat page
  └─> REST API: load message history (GET /api/messages/<user_id>/)
  └─> WebSocket: connect (ws/chat/<user_id>/)
        └─> on send: WebSocket → server saves to DB → broadcast to room
        └─> on receive: render bubble + send read receipt
```

---

## 1. Entry Point & Access Control

**View:** `start_message_chat` in `core_chatsphere/views.py`
**URL:** `/messages/<user_id>/`

Before rendering the chat page, two guards are enforced:

- The logged-in user must **not be banned**
- The target user must be a **bidirectional connection** — both users must have a `Connection` record pointing to each other

The sidebar lists all connected users, each annotated with an `unread_count` of messages not yet read.

---

## 2. WebSocket Connection

**WS URL:** `ws/chat/<user_id>/`
**Router:** `core_chatsphere/routing.py`
**Consumer:** `ChatConsumer` in `core_chatsphere/consumers.py`

### On connect:
1. A **deterministic room name** is generated by sorting both user IDs: `chat_<min_id>_<max_id>` — guaranteeing both users always join the same channel group regardless of who initiates.
2. **Permission check** (`can_chat`): queries the `Connection` model for a bidirectional link. If not connected, the socket is closed immediately.
3. An **`online` presence event** is broadcast to the room so the other user's status indicator goes green.

### On disconnect:
An **`offline` presence event** is broadcast to the room.

---

## 3. Sending a Message

```
User types → Enter / Send button
  └─> messaging.js sends over WebSocket:
        { "type": "chat_message", "message": "..." }
  └─> ChatConsumer.receive()
        └─> handle_chat_message()
              └─> save_message() → writes ConversationMessage to DB
              └─> group_send() → broadcasts to entire room group
  └─> Both users' sockets receive the event
  └─> messaging.js renders message bubble
```

If the WebSocket is not open when the user sends, the message is **queued** in memory and flushed once the connection is restored.

---

## 4. Data Model — `ConversationMessage`

Defined in `core_chatsphere/models.py`.

| Field         | Type          | Description                        |
|---------------|---------------|------------------------------------|
| `sender`      | FK → User     | User who sent the message          |
| `receiver`    | FK → User     | User who received the message      |
| `conv_message`| TextField     | The text body                      |
| `created_at`  | DateTimeField | Auto-set on creation               |
| `is_read`     | BooleanField  | Whether the receiver has read it   |
| `read_at`     | DateTimeField | Timestamp when marked as read      |

The serializer (`core_chatsphere/serializers.py`) also exposes `sender_username`, `sender_full_name`, and `receiver_username` as read-only fields for API responses.

---

## 5. Read Receipts

Two mechanisms work in tandem:

### Bulk mark-as-read (on page load)
When the chat opens, the JS client calls:
```
POST /api/messages/<user_id>/read/
```
This bulk-updates all unread messages from that user to `is_read=True` and sets `read_at`. The unread badge in the sidebar is then removed.

### Per-message read receipt (real-time)
When a new message arrives over WebSocket and the current user is the receiver:
1. JS sends `{ "type": "mark_as_read", "message_id": ... }` over the socket
2. Server updates `is_read=True` and `read_at` in the DB
3. Server broadcasts a `message_read` event to the room
4. Sender's JS receives it and updates the checkmark: `✓` → `✓✓`

---

## 6. Message History (REST API)

**Endpoint:** `GET /api/messages/<user_id>/`
**View:** `get_message_history` in `core_chatsphere/views.py`

On page load, before the WebSocket connects, the JS client fetches all prior messages between the two users ordered by `created_at` and renders them. This ensures past conversation is visible immediately, before the real-time socket is established.

---

## 7. Reconnection Logic

If the WebSocket drops unexpectedly, the client retries automatically using **exponential backoff**:

- Max attempts: 5
- Base delay: 3 000 ms
- Formula: `delay = 3000 * 2^attempt`

Unsent messages are held in a queue and flushed once the connection is restored.

---

## 8. Infrastructure

`chatsphere/asgi.py` wires everything together using Django Channels' `ProtocolTypeRouter`:

```
Incoming request
  ├─ HTTP  → standard Django ASGI app
  └─ WS    → AuthMiddlewareStack
                └─> URLRouter (websocket_urlpatterns)
                      └─> ChatConsumer
```

`AuthMiddlewareStack` ensures `scope['user']` is populated from the Django session, so the consumer has access to the authenticated user without any extra auth logic.

---

## File Reference

| File | Role |
|------|------|
| `core_chatsphere/consumers.py` | WebSocket consumer — connect, receive, broadcast |
| `core_chatsphere/routing.py` | Maps WS URLs to consumers |
| `core_chatsphere/serializers.py` | Serializes `ConversationMessage` for REST responses |
| `core_chatsphere/models.py` | `ConversationMessage` model |
| `core_chatsphere/views.py` | Page view + REST API endpoints for history and read receipts |
| `static/js/messaging.js` | Frontend WebSocket client + UI rendering |
| `chatsphere/asgi.py` | ASGI routing (HTTP vs WebSocket) |
